// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"sync"

	"github.com/hyperledger/fabric-cli/pkg/fabric"
	"github.com/hyperledger/fabric-sdk-go/pkg/common/providers/fab"
)

type Event struct {
	RegisterBlockEventStub        func(filter ...fab.BlockFilter) (fab.Registration, <-chan *fab.BlockEvent, error)
	registerBlockEventMutex       sync.RWMutex
	registerBlockEventArgsForCall []struct {
		filter []fab.BlockFilter
	}
	registerBlockEventReturns struct {
		result1 fab.Registration
		result2 <-chan *fab.BlockEvent
		result3 error
	}
	registerBlockEventReturnsOnCall map[int]struct {
		result1 fab.Registration
		result2 <-chan *fab.BlockEvent
		result3 error
	}
	RegisterChaincodeEventStub        func(ccID, eventFilter string) (fab.Registration, <-chan *fab.CCEvent, error)
	registerChaincodeEventMutex       sync.RWMutex
	registerChaincodeEventArgsForCall []struct {
		ccID        string
		eventFilter string
	}
	registerChaincodeEventReturns struct {
		result1 fab.Registration
		result2 <-chan *fab.CCEvent
		result3 error
	}
	registerChaincodeEventReturnsOnCall map[int]struct {
		result1 fab.Registration
		result2 <-chan *fab.CCEvent
		result3 error
	}
	RegisterFilteredBlockEventStub        func() (fab.Registration, <-chan *fab.FilteredBlockEvent, error)
	registerFilteredBlockEventMutex       sync.RWMutex
	registerFilteredBlockEventArgsForCall []struct{}
	registerFilteredBlockEventReturns     struct {
		result1 fab.Registration
		result2 <-chan *fab.FilteredBlockEvent
		result3 error
	}
	registerFilteredBlockEventReturnsOnCall map[int]struct {
		result1 fab.Registration
		result2 <-chan *fab.FilteredBlockEvent
		result3 error
	}
	RegisterTxStatusEventStub        func(txID string) (fab.Registration, <-chan *fab.TxStatusEvent, error)
	registerTxStatusEventMutex       sync.RWMutex
	registerTxStatusEventArgsForCall []struct {
		txID string
	}
	registerTxStatusEventReturns struct {
		result1 fab.Registration
		result2 <-chan *fab.TxStatusEvent
		result3 error
	}
	registerTxStatusEventReturnsOnCall map[int]struct {
		result1 fab.Registration
		result2 <-chan *fab.TxStatusEvent
		result3 error
	}
	UnregisterStub        func(reg fab.Registration)
	unregisterMutex       sync.RWMutex
	unregisterArgsForCall []struct {
		reg fab.Registration
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *Event) RegisterBlockEvent(filter ...fab.BlockFilter) (fab.Registration, <-chan *fab.BlockEvent, error) {
	fake.registerBlockEventMutex.Lock()
	ret, specificReturn := fake.registerBlockEventReturnsOnCall[len(fake.registerBlockEventArgsForCall)]
	fake.registerBlockEventArgsForCall = append(fake.registerBlockEventArgsForCall, struct {
		filter []fab.BlockFilter
	}{filter})
	fake.recordInvocation("RegisterBlockEvent", []interface{}{filter})
	fake.registerBlockEventMutex.Unlock()
	if fake.RegisterBlockEventStub != nil {
		return fake.RegisterBlockEventStub(filter...)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.registerBlockEventReturns.result1, fake.registerBlockEventReturns.result2, fake.registerBlockEventReturns.result3
}

func (fake *Event) RegisterBlockEventCallCount() int {
	fake.registerBlockEventMutex.RLock()
	defer fake.registerBlockEventMutex.RUnlock()
	return len(fake.registerBlockEventArgsForCall)
}

func (fake *Event) RegisterBlockEventArgsForCall(i int) []fab.BlockFilter {
	fake.registerBlockEventMutex.RLock()
	defer fake.registerBlockEventMutex.RUnlock()
	return fake.registerBlockEventArgsForCall[i].filter
}

func (fake *Event) RegisterBlockEventReturns(result1 fab.Registration, result2 <-chan *fab.BlockEvent, result3 error) {
	fake.RegisterBlockEventStub = nil
	fake.registerBlockEventReturns = struct {
		result1 fab.Registration
		result2 <-chan *fab.BlockEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Event) RegisterBlockEventReturnsOnCall(i int, result1 fab.Registration, result2 <-chan *fab.BlockEvent, result3 error) {
	fake.RegisterBlockEventStub = nil
	if fake.registerBlockEventReturnsOnCall == nil {
		fake.registerBlockEventReturnsOnCall = make(map[int]struct {
			result1 fab.Registration
			result2 <-chan *fab.BlockEvent
			result3 error
		})
	}
	fake.registerBlockEventReturnsOnCall[i] = struct {
		result1 fab.Registration
		result2 <-chan *fab.BlockEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Event) RegisterChaincodeEvent(ccID string, eventFilter string) (fab.Registration, <-chan *fab.CCEvent, error) {
	fake.registerChaincodeEventMutex.Lock()
	ret, specificReturn := fake.registerChaincodeEventReturnsOnCall[len(fake.registerChaincodeEventArgsForCall)]
	fake.registerChaincodeEventArgsForCall = append(fake.registerChaincodeEventArgsForCall, struct {
		ccID        string
		eventFilter string
	}{ccID, eventFilter})
	fake.recordInvocation("RegisterChaincodeEvent", []interface{}{ccID, eventFilter})
	fake.registerChaincodeEventMutex.Unlock()
	if fake.RegisterChaincodeEventStub != nil {
		return fake.RegisterChaincodeEventStub(ccID, eventFilter)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.registerChaincodeEventReturns.result1, fake.registerChaincodeEventReturns.result2, fake.registerChaincodeEventReturns.result3
}

func (fake *Event) RegisterChaincodeEventCallCount() int {
	fake.registerChaincodeEventMutex.RLock()
	defer fake.registerChaincodeEventMutex.RUnlock()
	return len(fake.registerChaincodeEventArgsForCall)
}

func (fake *Event) RegisterChaincodeEventArgsForCall(i int) (string, string) {
	fake.registerChaincodeEventMutex.RLock()
	defer fake.registerChaincodeEventMutex.RUnlock()
	return fake.registerChaincodeEventArgsForCall[i].ccID, fake.registerChaincodeEventArgsForCall[i].eventFilter
}

func (fake *Event) RegisterChaincodeEventReturns(result1 fab.Registration, result2 <-chan *fab.CCEvent, result3 error) {
	fake.RegisterChaincodeEventStub = nil
	fake.registerChaincodeEventReturns = struct {
		result1 fab.Registration
		result2 <-chan *fab.CCEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Event) RegisterChaincodeEventReturnsOnCall(i int, result1 fab.Registration, result2 <-chan *fab.CCEvent, result3 error) {
	fake.RegisterChaincodeEventStub = nil
	if fake.registerChaincodeEventReturnsOnCall == nil {
		fake.registerChaincodeEventReturnsOnCall = make(map[int]struct {
			result1 fab.Registration
			result2 <-chan *fab.CCEvent
			result3 error
		})
	}
	fake.registerChaincodeEventReturnsOnCall[i] = struct {
		result1 fab.Registration
		result2 <-chan *fab.CCEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Event) RegisterFilteredBlockEvent() (fab.Registration, <-chan *fab.FilteredBlockEvent, error) {
	fake.registerFilteredBlockEventMutex.Lock()
	ret, specificReturn := fake.registerFilteredBlockEventReturnsOnCall[len(fake.registerFilteredBlockEventArgsForCall)]
	fake.registerFilteredBlockEventArgsForCall = append(fake.registerFilteredBlockEventArgsForCall, struct{}{})
	fake.recordInvocation("RegisterFilteredBlockEvent", []interface{}{})
	fake.registerFilteredBlockEventMutex.Unlock()
	if fake.RegisterFilteredBlockEventStub != nil {
		return fake.RegisterFilteredBlockEventStub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.registerFilteredBlockEventReturns.result1, fake.registerFilteredBlockEventReturns.result2, fake.registerFilteredBlockEventReturns.result3
}

func (fake *Event) RegisterFilteredBlockEventCallCount() int {
	fake.registerFilteredBlockEventMutex.RLock()
	defer fake.registerFilteredBlockEventMutex.RUnlock()
	return len(fake.registerFilteredBlockEventArgsForCall)
}

func (fake *Event) RegisterFilteredBlockEventReturns(result1 fab.Registration, result2 <-chan *fab.FilteredBlockEvent, result3 error) {
	fake.RegisterFilteredBlockEventStub = nil
	fake.registerFilteredBlockEventReturns = struct {
		result1 fab.Registration
		result2 <-chan *fab.FilteredBlockEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Event) RegisterFilteredBlockEventReturnsOnCall(i int, result1 fab.Registration, result2 <-chan *fab.FilteredBlockEvent, result3 error) {
	fake.RegisterFilteredBlockEventStub = nil
	if fake.registerFilteredBlockEventReturnsOnCall == nil {
		fake.registerFilteredBlockEventReturnsOnCall = make(map[int]struct {
			result1 fab.Registration
			result2 <-chan *fab.FilteredBlockEvent
			result3 error
		})
	}
	fake.registerFilteredBlockEventReturnsOnCall[i] = struct {
		result1 fab.Registration
		result2 <-chan *fab.FilteredBlockEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Event) RegisterTxStatusEvent(txID string) (fab.Registration, <-chan *fab.TxStatusEvent, error) {
	fake.registerTxStatusEventMutex.Lock()
	ret, specificReturn := fake.registerTxStatusEventReturnsOnCall[len(fake.registerTxStatusEventArgsForCall)]
	fake.registerTxStatusEventArgsForCall = append(fake.registerTxStatusEventArgsForCall, struct {
		txID string
	}{txID})
	fake.recordInvocation("RegisterTxStatusEvent", []interface{}{txID})
	fake.registerTxStatusEventMutex.Unlock()
	if fake.RegisterTxStatusEventStub != nil {
		return fake.RegisterTxStatusEventStub(txID)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.registerTxStatusEventReturns.result1, fake.registerTxStatusEventReturns.result2, fake.registerTxStatusEventReturns.result3
}

func (fake *Event) RegisterTxStatusEventCallCount() int {
	fake.registerTxStatusEventMutex.RLock()
	defer fake.registerTxStatusEventMutex.RUnlock()
	return len(fake.registerTxStatusEventArgsForCall)
}

func (fake *Event) RegisterTxStatusEventArgsForCall(i int) string {
	fake.registerTxStatusEventMutex.RLock()
	defer fake.registerTxStatusEventMutex.RUnlock()
	return fake.registerTxStatusEventArgsForCall[i].txID
}

func (fake *Event) RegisterTxStatusEventReturns(result1 fab.Registration, result2 <-chan *fab.TxStatusEvent, result3 error) {
	fake.RegisterTxStatusEventStub = nil
	fake.registerTxStatusEventReturns = struct {
		result1 fab.Registration
		result2 <-chan *fab.TxStatusEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Event) RegisterTxStatusEventReturnsOnCall(i int, result1 fab.Registration, result2 <-chan *fab.TxStatusEvent, result3 error) {
	fake.RegisterTxStatusEventStub = nil
	if fake.registerTxStatusEventReturnsOnCall == nil {
		fake.registerTxStatusEventReturnsOnCall = make(map[int]struct {
			result1 fab.Registration
			result2 <-chan *fab.TxStatusEvent
			result3 error
		})
	}
	fake.registerTxStatusEventReturnsOnCall[i] = struct {
		result1 fab.Registration
		result2 <-chan *fab.TxStatusEvent
		result3 error
	}{result1, result2, result3}
}

func (fake *Event) Unregister(reg fab.Registration) {
	fake.unregisterMutex.Lock()
	fake.unregisterArgsForCall = append(fake.unregisterArgsForCall, struct {
		reg fab.Registration
	}{reg})
	fake.recordInvocation("Unregister", []interface{}{reg})
	fake.unregisterMutex.Unlock()
	if fake.UnregisterStub != nil {
		fake.UnregisterStub(reg)
	}
}

func (fake *Event) UnregisterCallCount() int {
	fake.unregisterMutex.RLock()
	defer fake.unregisterMutex.RUnlock()
	return len(fake.unregisterArgsForCall)
}

func (fake *Event) UnregisterArgsForCall(i int) fab.Registration {
	fake.unregisterMutex.RLock()
	defer fake.unregisterMutex.RUnlock()
	return fake.unregisterArgsForCall[i].reg
}

func (fake *Event) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.registerBlockEventMutex.RLock()
	defer fake.registerBlockEventMutex.RUnlock()
	fake.registerChaincodeEventMutex.RLock()
	defer fake.registerChaincodeEventMutex.RUnlock()
	fake.registerFilteredBlockEventMutex.RLock()
	defer fake.registerFilteredBlockEventMutex.RUnlock()
	fake.registerTxStatusEventMutex.RLock()
	defer fake.registerTxStatusEventMutex.RUnlock()
	fake.unregisterMutex.RLock()
	defer fake.unregisterMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *Event) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ fabric.Event = new(Event)
